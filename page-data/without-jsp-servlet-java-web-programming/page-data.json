{"componentChunkName":"component---src-pages-contentful-post-slug-tsx","path":"/without-jsp-servlet-java-web-programming/","result":{"data":{"contentfulPost":{"title":"서블릿/JSP 없이 HTTP 웹서버 구현하기","category":["Web"],"date":"2024-08-19","slug":"without-jsp-servlet-java-web-programming","thumbnail":{"url":"https://images.ctfassets.net/w6wmczdusxy8/6sjKx5PLZ2Yssdvx256IN1/99a08466e380d3429db00cf73a15573b/___________2024-08-18______11.48.55.png","gatsbyImageData":{"images":{"sources":[{"srcSet":"https://images.ctfassets.net/w6wmczdusxy8/6sjKx5PLZ2Yssdvx256IN1/99a08466e380d3429db00cf73a15573b/___________2024-08-18______11.48.55.png?w=250&h=156&q=50&fm=webp 250w,\nhttps://images.ctfassets.net/w6wmczdusxy8/6sjKx5PLZ2Yssdvx256IN1/99a08466e380d3429db00cf73a15573b/___________2024-08-18______11.48.55.png?w=500&h=311&q=50&fm=webp 500w,\nhttps://images.ctfassets.net/w6wmczdusxy8/6sjKx5PLZ2Yssdvx256IN1/99a08466e380d3429db00cf73a15573b/___________2024-08-18______11.48.55.png?w=1000&h=622&q=50&fm=webp 1000w","sizes":"(min-width: 1000px) 1000px, 100vw","type":"image/webp"}],"fallback":{"src":"https://images.ctfassets.net/w6wmczdusxy8/6sjKx5PLZ2Yssdvx256IN1/99a08466e380d3429db00cf73a15573b/___________2024-08-18______11.48.55.png?w=1000&h=622&q=50&fm=png","srcSet":"https://images.ctfassets.net/w6wmczdusxy8/6sjKx5PLZ2Yssdvx256IN1/99a08466e380d3429db00cf73a15573b/___________2024-08-18______11.48.55.png?w=250&h=156&q=50&fm=png 250w,\nhttps://images.ctfassets.net/w6wmczdusxy8/6sjKx5PLZ2Yssdvx256IN1/99a08466e380d3429db00cf73a15573b/___________2024-08-18______11.48.55.png?w=500&h=311&q=50&fm=png 500w,\nhttps://images.ctfassets.net/w6wmczdusxy8/6sjKx5PLZ2Yssdvx256IN1/99a08466e380d3429db00cf73a15573b/___________2024-08-18______11.48.55.png?w=1000&h=622&q=50&fm=png 1000w","sizes":"(min-width: 1000px) 1000px, 100vw"}},"layout":"constrained","backgroundColor":"#f8f8f8","width":1000,"height":622}},"description":{"description":"자바 웹프로그래밍 Next Step의 3, 4, 5장을 직접 실습하며 정리한 글"},"content":{"raw":"{\"nodeType\":\"document\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"자바 웹 프로그래밍 Next Step을 실습하는 과정 중 작성한 글이다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-2\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"실습 환경\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"embedded-asset-block\",\"data\":{\"target\":{\"sys\":{\"id\":\"6sjKx5PLZ2Yssdvx256IN1\",\"type\":\"Link\",\"linkType\":\"Asset\"}}},\"content\":[]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"기존 코드 중 핵심이 되는 코드는 webserver 패키지의 WebServer와 RequestHandler 클래스이다. WebServer 클래스는 웹서버를 시작하고, 사용자의 요청이 있을 때까지 대기 상태로 있는다. 사용자 요청이 들어오면 RequestHandler 클래스에 요청 처리를 위임한다. 사용자의 요청이 있을 때까지 대기할 수 있도록 지원하는 ServerSocket 클래스를 이용한다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"RequestHandler 클래스는 Thread를 상속하고 있다. 사용자의 요청에 대한 처리와 응답을 담당하는 가장 중요한 클래스다. RequestHandler의 run() 메서드에서 사용자의 요청에 대한 처리와 응답을 구현해야 한다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"language::java\\n// RequestHandler 클래스\\npublic void run() {\\n\\tlog.debug(\\\"New Client Connect! Connected IP : {}, Port : {}\\\", connection.getInetAddress(),\\n\\tconnection.getPort());\\n\\n\\ttry (InputStream in = connection.getInputStream(); OutputStream out = connection.getOutputStream()) {\\n\\t\\tDataOutputStream dos = new DataOutputStream(out);\\n\\t\\tbyte[] body = \\\"Hello World\\\".getBytes();\\n\\t\\tresponse200Header(dos, body.length);\\n\\t\\tresponseBody(dos, body);\\n\\t\\t} catch (IOException e) {\\n\\t\\t\\t\\tlog.error(e.getMessage());\\n\\t\\t}\\n}\",\"marks\":[{\"type\":\"code\"}],\"data\":{}}]},{\"nodeType\":\"heading-2\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"HTTP 요청, 응답 처리하기\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"HTTP 형식으로 들어오는 요청인 InputStream을 처리해야 한다. 응답은 HTTP 형식으로 OutputStream을 세팅해 내보내야 한다. \",\"marks\":[],\"data\":{}},{\"nodeType\":\"hyperlink\",\"data\":{\"uri\":\"https://jihun-24k.github.io/http-structure/\"},\"content\":[{\"nodeType\":\"text\",\"value\":\"HTTP 통신 구조\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"text\",\"value\":\"에 맞춰 필요한 데이터를 추출하고 사용한다. HTTP 메서드(GET, POST)에 따라 다른 응답, url 뒤에 쿼리가 붙었을 때의 응답 등을 처리해서 run 메서드를 구현했다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"HTTP 요청 처리\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"language::java\\ntry (InputStream in = connection.getInputStream(); OutputStream out = connection.getOutputStream()) {\\n\\n\\tBufferedReader bufferIn = new BufferedReader(new InputStreamReader(in));\\n\\n\\tString line = bufferIn.readLine();\\n\\tString[] tokens = line.split(\\\" \\\");\\n\\n\\tString httpMethod = tokens[0];\\n\\tString url = tokens[1];\\n\\tUser createdUser;\\n\\tMap<String, String> userInfo = null;\\n\\n\\tint index = url.indexOf(\\\"?\\\");\\n\\tString requestUrl = url;\\n\\tif (index > 0) {\\n\\t\\trequestUrl = url.substring(0, index);\\n\\t\\tString params = url.substring(index + 1);\\n\\t\\tuserInfo = HttpRequestUtils.parseQueryString(params);\\n\\n\\t\\tcreatedUser = new User(\\n\\t\\t\\t\\tuserInfo.get(\\\"userId\\\"),\\n\\t\\t\\t\\tuserInfo.get(\\\"password\\\"),\\n\\t\\t\\t\\tuserInfo.get(\\\"name\\\"),\\n\\t\\t\\t\\tuserInfo.get(\\\"email\\\")\\n\\t\\t);\\n\\t\\t\\tDataBase.addUser(createdUser);\\n\\t}\\n\\n\\tMap<String, String> httpHeader = new HashMap<>();\\n\\n\\tlog.debug(\\\"HTTP RequestLine Info = {}\\\", line);\\n\\t\\twhile (!\\\"\\\".equals(line) && line != null) {\\n\\t\\t\\tline = bufferIn.readLine();\\n\\t\\t\\tlog.debug(\\\"HTTP Header Info = {}\\\", line);\\n\\t\\t\\tif (line == null || \\\"\\\".equals(line)) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tString[] info = line.split(\\\": \\\");\\n\\t\\t\\thttpHeader.put(info[0], info[1]);\\n\\t}\\n\\n\\tif (httpMethod.equals(\\\"POST\\\")) {\\n\\tint contentLength = Integer.parseInt(httpHeader.get(\\\"Content-Length\\\"));\\n\\tString httpBody = IOUtils.readData(bufferIn, contentLength);\\n\\n\\tuserInfo = HttpRequestUtils.parseQueryString(httpBody);\\n\\n\\tif (requestUrl.equals(\\\"/user/create\\\")) {\\n\\t\\t\\tcreatedUser = new User(\\n\\t\\t\\tuserInfo.get(\\\"userId\\\"),\\n\\t\\t\\tuserInfo.get(\\\"password\\\"),\\n\\t\\t\\tuserInfo.get(\\\"name\\\"),\\n\\t\\t\\tuserInfo.get(\\\"email\\\")\\n\\t\\t);\\n\\t\\tDataBase.addUser(createdUser);\\n\\t\\t}\\n\\t}\\n\\t...\\n}\",\"marks\":[{\"type\":\"code\"}],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"run 메서드 상단 부분에서 HTTP 요청을 처리하는 코드다. 요청 라인에서 HTTP 메서드, URL 데이터를 추출해 그에 맞는 기능을 실행한다. 마찬가지로 요청 헤더, 요청 본문에 데이터도 따로 추출해 관리한다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"HTTP 응답 처리\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"language::java\\n...\\n\\nDataOutputStream dos = new DataOutputStream(out);\\nbyte[] body = new byte[0];\\n\\nif (requestUrl.equals(\\\"/user/create\\\")) {\\n\\tresponse302Header(dos);\\n\\tresponseBody(dos, body);\\n\\t}\\n\\telse if (requestUrl.equals(\\\"/user/login\\\")) {\\n\\t\\tif (httpMethod.equals(\\\"POST\\\")) {\\n\\t\\t\\tString userId = userInfo.get(\\\"userId\\\");\\n\\t\\t\\tUser user = DataBase.findUserById(userId);\\n\\n\\t\\t\\tif (user != null && user.getPassword().equals(userInfo.get(\\\"password\\\"))) {\\n\\t\\t\\t\\tresponseSetCookieHeader(dos, \\\"/index.html\\\",\\\"logined=true\\\");\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tresponseSetCookieHeader(dos, \\\"/user/login_failed.html\\\", \\\"logined=false\\\");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\telse if(requestUrl.equals(\\\"/user/list\\\")) {\\n\\t\\tMap<String, String> cookies = HttpRequestUtils.parseCookies(httpHeader.get(\\\"Cookie\\\"));\\n\\t\\tboolean isLogined = Boolean.parseBoolean(cookies.get(\\\"logined\\\"));\\n\\t\\tif (isLogined) {\\n\\t\\t\\tStringBuilder userList = new StringBuilder();\\n\\n\\t\\t\\tfor (User user : DataBase.findAll()) {\\n\\t\\t\\t\\t\\tuserList.append(\\\"<tr>\\\");\\n\\t\\t\\t\\t\\tuserList.append(\\\"<th scope='row'>\\\").append(index++).append(\\\"</th>\\\");\\n\\t\\t\\t\\t\\tuserList.append(\\\"<td>\\\").append(user.getUserId()).append(\\\"</td>\\\");\\n\\t\\t\\t\\t\\tuserList.append(\\\"<td>\\\").append(user.getName()).append(\\\"</td>\\\");\\n\\t\\t\\t\\t\\tuserList.append(\\\"<td>\\\").append(user.getEmail()).append(\\\"</td>\\\");\\n\\t\\t\\t\\t\\tuserList.append(\\\"<td><a href='#' class='btn btn-success' role='button'>수정</a></td>\\\");\\n\\t\\t\\t\\t\\tuserList.append(\\\"</tr>\\\");\\n\\t\\t\\t}\\n\\t\\n\\t\\t\\tbody = userList.toString().getBytes();\\n\\t\\t\\tresponse200Header(dos, body.length);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tresponse302Header(dos);\\n\\t\\t}\\n\\t}\\n\\telse if (requestUrl.equals(\\\"/css/styles.css\\\")) {\\n\\t\\tbody = Files.readAllBytes(new File(\\\"./webapp\\\" + requestUrl).toPath());\\n\\t\\tresponseCSSHeader(dos, body.length);\\n\\t}\\n\\telse {\\n\\t\\tbody = Files.readAllBytes(new File(\\\"./webapp\\\" + requestUrl).toPath());\\n\\t\\tresponse200Header(dos, body.length);\\n\\t}\\nresponseBody(dos, body);\\n...\\n// 응답 헤더, 응답 본문을 다루는 메서드\",\"marks\":[{\"type\":\"code\"}],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"URL에 맞는 HTTP 응답을 생성해서 보내주는 역할을 한다. 여기서는 로그인을 했는지 안했는지에 따라서도 응답을 어떻게 생성할지 if-문 분기로 나눠 동작한다. 제각기 다른 응답을 보내야 하기에 응답 헤더와 응답 본문을 만드는 메서드를 따로 만들어 구현했다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-2\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"리팩토링\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"고민 1. 너무 많은 처리를 run 메서드에서 담당한다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"요청과 응답을 모두 담당하면서 run 메서드가 매우 커졌다. 기능이 추가되면서 이 양은 더 불어날게 분명하다. 요청 따로 처리하는 \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"HttpRequest\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" 와 응답을 따로 처리하는 \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"HttpResponse\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" 클래스를 만들어 리팩토링을 진행 했다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"HttpRequest\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"language::java\\npublic class HttpRequest {\\n    private static final Logger log = LoggerFactory.getLogger(HttpRequest.class);\\n    private String method;\\n    private String path;\\n    private Map<String, String> params = new HashMap<>();\\n    private Map<String, String> header = new HashMap<>();\\n\\n    public HttpRequest(InputStream in) throws IOException {\\n        BufferedReader bufferIn = new BufferedReader(new InputStreamReader(in));\\n\\n        String line = bufferIn.readLine();\\n        extractRequestLine(line);\\n\\n        log.debug(\\\"HTTP RequestLine Info = {}\\\", line);\\n        while (line != null && !\\\"\\\".equals(line)) {\\n\\n            line = bufferIn.readLine();\\n            if (line == null || \\\"\\\".equals(line)) {\\n                break;\\n            }\\n            extractHeader(line);\\n        }\\n\\n        if (method.equals(\\\"POST\\\")) {\\n            int contentLength = Integer.parseInt(header.get(\\\"Content-Length\\\"));\\n            String body = IOUtils.readData(bufferIn, contentLength);\\n            params = HttpRequestUtils.parseQueryString(body);\\n        }\\n    }\\n\\n    private void extractHeader(String line) {\\n        log.debug(\\\"HTTP Header Info = {}\\\", line);\\n\\n        String[] info = line.split(\\\": \\\");\\n        header.put(info[0], info[1]);\\n    }\\n\\n    private void extractRequestLine(String line) {\\n        String[] tokens = line.split(\\\" \\\");\\n\\n        method = tokens[0];\\n        extractPathAndParams(tokens[1]);\\n    }\\n\\n    private void extractPathAndParams(String url) {\\n        if (url.startsWith(\\\"/user/create?\\\")) {\\n            int index = url.indexOf(\\\"?\\\");\\n            path = url.substring(0, index);\\n            params = HttpRequestUtils.parseQueryString(url.substring(index + 1));\\n        }\\n        else {\\n            path = url;\\n        }\\n    }\\n\\n    public String getMethod() {\\n        return method;\\n    }\\n\\n    public String getPath() {\\n        return path;\\n    }\\n\\n    public String getParameter(String key) {\\n        return params.get(key);\\n    }\\n\\n    public String getHeader(String key) {\\n        return header.get(key);\\n    }\\n}\",\"marks\":[{\"type\":\"code\"}],\"data\":{}}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"HttpResponse\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"language::java\\npublic class HttpResponse {\\n    private static final Logger log = LoggerFactory.getLogger(HttpResponse.class);\\n    private DataOutputStream dos;\\n    private Map<String, String> header = new HashMap<>();\\n\\n    public HttpResponse(OutputStream out) {\\n        dos = new DataOutputStream(out);\\n    }\\n\\n    public void forward(String path) throws IOException {\\n        byte[] body = Files.readAllBytes(new File(\\\"./webapp\\\" + path).toPath());\\n\\n        if (path.endsWith(\\\".css\\\")) {\\n            addHeader(\\\"Content-Type\\\", \\\"text/css;\\\");\\n        }\\n        if (path.endsWith(\\\".html\\\")) {\\n            addHeader(\\\"Content-Type\\\", \\\"text/html;charset=utf-8;\\\");\\n        }\\n        if (path.endsWith(\\\".js\\\")) {\\n            addHeader(\\\"Content-Type\\\", \\\"application/javascript;\\\");\\n        }\\n        addHeader(\\\"Content-Length\\\", body.length + \\\"\\\");\\n        response200Header();\\n        responseBody(body);\\n    }\\n    public void forwardBody(String body) {\\n        byte[] contents = body.getBytes();\\n        addHeader(\\\"Content-Type\\\", \\\"text/html;charset=utf-8;\\\");\\n        addHeader(\\\"Content-Length\\\", contents.length + \\\"\\\");\\n        response200Header();\\n        responseBody(contents);\\n    }\\n\\n    public void sendRedirect(String path) {\\n        try {\\n            dos.writeBytes(\\\"HTTP/1.1 302 Found \\\\\\\\r\\\\\\\\n\\\");\\n            processHeaders();\\n            dos.writeBytes(\\\"Location: <http://localhost:8080>\\\" + path + \\\"\\\\\\\\r\\\\\\\\n\\\");\\n            dos.writeBytes(\\\"\\\\\\\\r\\\\\\\\n\\\");\\n        } catch (IOException e) {\\n            log.error(e.getMessage());\\n        }\\n    }\\n\\n    public void addHeader(String key, String value) {\\n        header.put(key, value);\\n    }\\n\\n    private void response200Header() {\\n        try {\\n            dos.writeBytes(\\\"HTTP/1.1 200 OK \\\\\\\\r\\\\\\\\n\\\");\\n            processHeaders();\\n            dos.writeBytes(\\\"\\\\\\\\r\\\\\\\\n\\\");\\n        } catch (IOException e) {\\n            log.error(e.getMessage());\\n        }\\n    }\\n\\n    private void responseBody(byte[] body) {\\n        try {\\n            dos.write(body, 0, body.length);\\n            dos.flush();\\n        } catch (IOException e) {\\n            log.error(e.getMessage());\\n        }\\n    }\\n\\n    private void processHeaders() {\\n        try {\\n            for (Entry<String, String> keyValue : header.entrySet()) {\\n                dos.writeBytes(keyValue.getKey() + \\\": \\\" + keyValue.getValue() + \\\"\\\\\\\\r\\\\\\\\n\\\");\\n            }\\n        } catch (IOException io) {\\n            log.error(io.getMessage());\\n        }\\n    }\\n}\",\"marks\":[{\"type\":\"code\"}],\"data\":{}}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"고민 2. 너무 많은 분기문으로 복잡하다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"URL에 따라서 응답을 다르게 해주면서 if 분기문이 많이 생겼다. 이런 분기문을 추상화를 통해 리팩토링하면 깔끔하게 처리 할 수 있다. Controller라는 인터페이스로 추상화한다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Controller 인터페이스로 추상화\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"\\n\",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"language::java\\npublic interface Controller {\\n    void service(HttpRequest request, HttpResponse response);\\n}\",\"marks\":[{\"type\":\"code\"}],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"Controller를 구현하는 클래스들을 만든다. Controller 인터페이스를 그대로 상속받아 구현할 수도 있다. 하지만 안에서 GET과 POST 같은 HTTP 요청 메서드에 따라서 분기가 생긴다. 분기를 없애기 위해 Controller 인터페이스를 상속한 추상 클래스를 만들어 준다. 직접 구현 코드는 추상 클래스를 상속함으로써 요청 메서드에 따른 분기문을 해결 할 수 있다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"language::java\\npublic class AbstractController implements Controller{\\n    @Override\\n    public void service(HttpRequest request, HttpResponse response) {\\n        if (request.equalsMethod(\\\"GET\\\")) {\\n            doGet(request, response);\\n        }\\n        if (request.equalsMethod(\\\"POST\\\")) {\\n            doPost(request, response);\\n        }\\n\\n    }\\n    protected void doGet(HttpRequest request, HttpResponse response) {}\\n    protected void doPost(HttpRequest request, HttpResponse response) {}\\n}\",\"marks\":[{\"type\":\"code\"}],\"data\":{}}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"RequestMapping 클래스에 Controller 연결 역할 위임\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"모든 URL과 Controller를 관리해주는 클래스를 추가한다. 요청 URL에 맞는 Controller를 반환하는 역할을 담당한다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"language::java\\npublic class RequestMapping {\\n    private static Map<String, Controller> controllers = new HashMap<>();\\n\\n    static {\\n        controllers.put(\\\"/user/create\\\", new CreateUserController());\\n        controllers.put(\\\"/user/login\\\", new LoginController());\\n        controllers.put(\\\"/user/list\\\", new ListUserController());\\n    }\\n\\n    public static Controller getController(String requestUrl) {\\n        return controllers.get(requestUrl);\\n    }\\n}\",\"marks\":[{\"type\":\"code\"}],\"data\":{}}]},{\"nodeType\":\"heading-2\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"리팩토링 결과\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"역할에 따른 클래스를 만든 후 run 메서드는 다음과 같이 깔끔해졌다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"language::java\\npublic class RequestHandler extends Thread {\\n    private static final Logger log = LoggerFactory.getLogger(RequestHandler.class);\\n\\n    private Socket connection;\\n\\n    public RequestHandler(Socket connectionSocket) {\\n        this.connection = connectionSocket;\\n    }\\n\\n    public void run() {\\n        log.debug(\\\"New Client Connect! Connected IP : {}, Port : {}\\\", connection.getInetAddress(),\\n                connection.getPort());\\n\\n        try (InputStream in = connection.getInputStream(); OutputStream out = connection.getOutputStream()) {\\n\\n            HttpRequest request = new HttpRequest(in);\\n            HttpResponse response = new HttpResponse(out);\\n\\n            Controller controller = RequestMapping.getController(request.getPath());\\n            if (controller == null) {\\n                String path = getDefaultPath(request.getPath());\\n                response.forward(path);\\n            } else {\\n                controller.service(request, response);\\n            }\\n\\n        } catch (IOException e) {\\n            log.error(e.getMessage());\\n        }\\n    }\\n\\n    private String getDefaultPath(String path) {\\n        if (path.equals(\\\"/\\\")) {\\n            return \\\"/index.html\\\";\\n        }\\n        return path;\\n    }\\n}\",\"marks\":[{\"type\":\"code\"}],\"data\":{}}]},{\"nodeType\":\"heading-2\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"마무리\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"웹 서버를 직접 구현하고 리팩토링 했다. 이 과정을 통해 다음과 같은 한계가 드러났다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"unordered-list\",\"data\":{},\"content\":[{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"간단한 요청, 응답을 처리하는데도 많은 시간이 걸렸다. 그래서 정작 중요한 비즈니스 로직을 작성할 시간이 빼앗겼다.\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"동적인 HTML을 지원하는 데 한계가 있다. 너무나 많은 코딩량을 필요로 하기 때문이다.\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"사용자가 입력한 데이터가 영구적으로 적용되지 않는다.\",\"marks\":[],\"data\":{}}]}]}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"여기서 앞선 두 한계는 서블릿 컨테이너와 서블릿/JSP로 해결이 가능하다. 다음엔 서블릿과 JSP를 이용해 웹 사이트 구현 해보고자 한다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-2\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"참고 자료\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"unordered-list\",\"data\":{},\"content\":[{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"박재성, 자바 웹 프로그래밍 Next Step, 로드북, 2016\",\"marks\":[],\"data\":{}}]}]}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"\",\"marks\":[],\"data\":{}}]}]}","references":[{"contentful_id":"6sjKx5PLZ2Yssdvx256IN1","title":"서블릿/JSP 없는 실습환경","description":"전체적인 실습 환경 구조","gatsbyImageData":{"images":{"sources":[{"srcSet":"https://images.ctfassets.net/w6wmczdusxy8/6sjKx5PLZ2Yssdvx256IN1/99a08466e380d3429db00cf73a15573b/___________2024-08-18______11.48.55.png?w=305&h=190&q=50&fm=webp 305w,\nhttps://images.ctfassets.net/w6wmczdusxy8/6sjKx5PLZ2Yssdvx256IN1/99a08466e380d3429db00cf73a15573b/___________2024-08-18______11.48.55.png?w=609&h=379&q=50&fm=webp 609w,\nhttps://images.ctfassets.net/w6wmczdusxy8/6sjKx5PLZ2Yssdvx256IN1/99a08466e380d3429db00cf73a15573b/___________2024-08-18______11.48.55.png?w=1218&h=758&q=50&fm=webp 1218w","sizes":"(min-width: 1218px) 1218px, 100vw","type":"image/webp"}],"fallback":{"src":"https://images.ctfassets.net/w6wmczdusxy8/6sjKx5PLZ2Yssdvx256IN1/99a08466e380d3429db00cf73a15573b/___________2024-08-18______11.48.55.png?w=1218&h=758&q=50&fm=png","srcSet":"https://images.ctfassets.net/w6wmczdusxy8/6sjKx5PLZ2Yssdvx256IN1/99a08466e380d3429db00cf73a15573b/___________2024-08-18______11.48.55.png?w=305&h=190&q=50&fm=png 305w,\nhttps://images.ctfassets.net/w6wmczdusxy8/6sjKx5PLZ2Yssdvx256IN1/99a08466e380d3429db00cf73a15573b/___________2024-08-18______11.48.55.png?w=609&h=379&q=50&fm=png 609w,\nhttps://images.ctfassets.net/w6wmczdusxy8/6sjKx5PLZ2Yssdvx256IN1/99a08466e380d3429db00cf73a15573b/___________2024-08-18______11.48.55.png?w=1218&h=758&q=50&fm=png 1218w","sizes":"(min-width: 1218px) 1218px, 100vw"}},"layout":"constrained","backgroundColor":"#f8f8f8","width":1218,"height":758},"__typename":"ContentfulAsset"}]}}},"pageContext":{"id":"6c413557-5b9c-5a51-8926-4ae5d4d6ac73","slug":"without-jsp-servlet-java-web-programming","__params":{"slug":"without-jsp-servlet-java-web-programming"}}},"staticQueryHashes":["506648845"],"slicesMap":{}}