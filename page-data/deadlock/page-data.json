{"componentChunkName":"component---src-pages-contentful-post-slug-tsx","path":"/deadlock/","result":{"data":{"contentfulPost":{"title":"교착상태(DeadLock)","category":["CS"],"date":"2024-09-01","slug":"deadlock","thumbnail":{"url":"https://images.ctfassets.net/w6wmczdusxy8/1iG6KZrs6Y9tc1pzFdszEe/60df56dd8ab0595ca0d1715ca48ff859/deadlock.png","gatsbyImageData":{"images":{"sources":[{"srcSet":"https://images.ctfassets.net/w6wmczdusxy8/1iG6KZrs6Y9tc1pzFdszEe/60df56dd8ab0595ca0d1715ca48ff859/deadlock.png?w=179&h=125&q=50&fm=webp 179w,\nhttps://images.ctfassets.net/w6wmczdusxy8/1iG6KZrs6Y9tc1pzFdszEe/60df56dd8ab0595ca0d1715ca48ff859/deadlock.png?w=358&h=251&q=50&fm=webp 358w,\nhttps://images.ctfassets.net/w6wmczdusxy8/1iG6KZrs6Y9tc1pzFdszEe/60df56dd8ab0595ca0d1715ca48ff859/deadlock.png?w=715&h=501&q=50&fm=webp 715w","sizes":"(min-width: 715px) 715px, 100vw","type":"image/webp"}],"fallback":{"src":"https://images.ctfassets.net/w6wmczdusxy8/1iG6KZrs6Y9tc1pzFdszEe/60df56dd8ab0595ca0d1715ca48ff859/deadlock.png?w=715&h=501&q=50&fm=png","srcSet":"https://images.ctfassets.net/w6wmczdusxy8/1iG6KZrs6Y9tc1pzFdszEe/60df56dd8ab0595ca0d1715ca48ff859/deadlock.png?w=179&h=125&q=50&fm=png 179w,\nhttps://images.ctfassets.net/w6wmczdusxy8/1iG6KZrs6Y9tc1pzFdszEe/60df56dd8ab0595ca0d1715ca48ff859/deadlock.png?w=358&h=251&q=50&fm=png 358w,\nhttps://images.ctfassets.net/w6wmczdusxy8/1iG6KZrs6Y9tc1pzFdszEe/60df56dd8ab0595ca0d1715ca48ff859/deadlock.png?w=715&h=501&q=50&fm=png 715w","sizes":"(min-width: 715px) 715px, 100vw"}},"layout":"constrained","backgroundColor":"#f8f8f8","width":1000,"height":701}},"description":{"description":"데드락 정의와 해결방법를 정리한 글"},"content":{"raw":"{\"nodeType\":\"document\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"특히 사거리 도로에서 꼬리물기를 하게되면 교차로에서 모든 차들의 진행방향이 막혀 교통마비가 되는 경우가 있다. 어느 차선에서도 다른 차선으로 가기 위해서는 가고자하는 차선이 비어있어야하는데 차선이 이미 차있어 가지 못하는 교착상태에 빠진다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"다중 프로그래밍 환경에서도 비슷한 일이 일어날 수 있다. A 스레드가 자원을 요청했는데 그 자원을 다른 B 스레드가 점유하고 있고 마찬가지로 점유하고 있는 B 스레드가 자원을 요청했는데 A 스레드가 점유하고 있다면 이도 저도 못하는 상황을 교착상태, \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"데드락(DeadLock)\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"이라고 한다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-2\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"교착 상태 발생 조건\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"그렇다면 교착상태는 어떤 상황일 때 발생할까? 아래 4가지 필요조건을 모두 만족해야지 데드락이 발생하게 된다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"ordered-list\",\"data\":{},\"content\":[{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"상호 배제(mutual exclusion)\",\"marks\":[{\"type\":\"bold\"}],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"점유하며 대기(hold and wait)\",\"marks\":[{\"type\":\"bold\"}],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"비선점(no preemption)\",\"marks\":[{\"type\":\"bold\"}],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"순환 대기(circular wait)\",\"marks\":[{\"type\":\"bold\"}],\"data\":{}}]}]}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"자원 할당 그래프\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"embedded-asset-block\",\"data\":{\"target\":{\"sys\":{\"id\":\"47smr1SMeai1W1TDv2guyv\",\"type\":\"Link\",\"linkType\":\"Asset\"}}},\"content\":[]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"그림과 같은 그래프를 \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"자원 할당 그래프\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"라고 한다. 교착 상태를 방향 그래프로 시각화하여 더 정확하게 기술할 수 있다. P는 프로세스를 뜻하고 R은 자원 유형을 뜻하며 R 안의 점은 자원의 개수를 뜻한다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"자원 할당 그래프에서 사이클(cycle)의 유무를 명확하게 확인할 수 있다. 사이클 유무의 정보로 사이클이 없다면 교착 상태가 아니다. 라고 정의할 수 있고 사이클이 있다면 교착 상태를 의심해봐야한다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-2\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"교착 상태 처리 방법\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"unordered-list\",\"data\":{},\"content\":[{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"문제를 무시하고, 교착 상태가 시스템에서 절대 발생하지 않게 한다.\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"시스템이 결코 교착 상태가 되지 않도록 보장하기 위하여 교착 상태를 예방하거나 회피하는 프로토콜을 사용 \",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"unordered-list\",\"data\":{},\"content\":[{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"교착 상태 예방 (prevention)\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\", \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"교착 상태 회피 (avoid)\",\"marks\":[{\"type\":\"code\"}],\"data\":{}}]}]}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"시스템이 교착 상태가 되도록 허용한 다음 교착 상태가 된다면 복구 시키는 방법\",\"marks\":[],\"data\":{}}]}]}]},{\"nodeType\":\"heading-2\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"교착상태 예방 방법\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"교착상태를 예방하려면 네 가지 필요조건이 다 만족해야하는데 이 말인 즉 최소 하나가 성립하지 않도록 보장하면 교착상태를 예방할 수 있다는 말이 된다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"상호배제\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"사실상 불가능하다. 이미 동기화문제를 처리하면서 근본적으로 공유가 불가능한 자원도 있기 때문이다. 예를들어 Mutex 락은 동시에 여러 스레드가 공유할 수 없다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"점유하며 대기\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"스레드가 자원을 요청할 때마다 다른 자원을 보유하지 않도록 보장해주면 된다. 이 문제를 해결하기 위해 2가지 프로토콜이 존재한다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"unordered-list\",\"data\":{},\"content\":[{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"각 스레드가 실행을 시작하기 전에 모든 자원을 요청하고 할당\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"스레드가 자원을 전혀 갖고 있지 않을때만 자원을 요청\",\"marks\":[],\"data\":{}}]}]}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"하지만 이 프로토콜은 두 가지 단점을 지니고 있다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"ordered-list\",\"data\":{},\"content\":[{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"자원이 할당 되었지만 장기간 사용하지 않을 수 있기 때문에 자원 이용률이 낮을 수 있다.\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"기아가 발생할 수 있다.\",\"marks\":[],\"data\":{}}]}]}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"비선점\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"스레드가 선점 당할 수 있도록 해준다. 그렇다면 이런 프로토콜을 생각할 수 있다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"unordered-list\",\"data\":{},\"content\":[{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"스레드가 반드시 대기해야한다면 현재 점유하고 있는 모든 자원이 선점된다. \",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"unordered-list\",\"data\":{},\"content\":[{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"스레드는 자신이 요청하고 있는 새로운 자원은 물론 이미 점유했던 옛 자원들을 다시 얻어야만 시작할 수 있게된다.\",\"marks\":[],\"data\":{}}]}]}]}]}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"비선점 방법은 CPU 레지스터나 데이터베이스 트랜잭션처럼 그 상태가 쉽게 저장되고 후에 복원될 수 잇는 자원에 종종 적용된다. 하지만 교착상태가 자주 발생하는 mutex 락과 세마포어 같은 자원에는 적용이 불가능하다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"순환 대기\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"이전 세가지 필요조건들 보다 실용적인 해결책을 제공해준다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"unordered-list\",\"data\":{},\"content\":[{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"모든 자원 유형에 전체적인 순서를 부여하여, 각 프로세스가 열거된 순서대로 오름차순으로 자원을 요청하도록 요구\",\"marks\":[],\"data\":{}}]}]}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"하지만 순환 대기를 해결해줘도 문제점이 발생한다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"unordered-list\",\"data\":{},\"content\":[{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"다른 스레드가 계속 중간에 열거된 자원을 점유하고 있다면 기아가 발생할 확률이 높아진다.\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"락 순서로 인한 교착 상태가 발생할 수 있다.\",\"marks\":[],\"data\":{}}]}]}]},{\"nodeType\":\"heading-2\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"교착 상태 회피\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"교착 상태 예방 방법은 장치의 이용률을 저하 시키거나 시스템 총 처리율(throughput)를 감소시킨다. 이렇게 된다면 멀티 스레드 환경을 사용하는 이유가 무색 해진다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"교착 상태 예방 방법 대안으로 교착 상태 회피가 제안됐다. 교착 상태를 회피하려면 어떤 방식을 사용해야할까? 각 스레드가 요청할 자원들의 \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"최대 수\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" 를 미리 파악해서 교착 상태에 빠지지 않도록 알고리즘을 작성하면된다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"교착 상태 회피 알고리즘은 시스템에 순환 대기 상황이 발생하지 않도록 자원할당 상태인 \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"가용 자원 수\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\", \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"할당된 자원의 수\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\" 그리고 \",\"marks\":[],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"스레드의 최대 요구 수\",\"marks\":[{\"type\":\"code\"}],\"data\":{}},{\"nodeType\":\"text\",\"value\":\"에 따라 작성된다. 회피 알고리즘에는 대표적으로 자원 할당 그래프 알고리즘과 뱅커스 알고리즘이 있다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"교착 상태 탐지\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"교착 상태를 방치하고 교착 상태가 일어나게 되면 다음 알고리즘들을 반드시 수행해야한다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"unordered-list\",\"data\":{},\"content\":[{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"교착 상태가 발생했는지 탐지하는 알고리즘\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"교착 상태로부터 회복하는 알고리즘\",\"marks\":[],\"data\":{}}]}]}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"교착 상태 탐지 알고리즘\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"unordered-list\",\"data\":{},\"content\":[{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"대기 그래프 Wait - for graph\",\"marks\":[{\"type\":\"bold\"}],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"각 자원이 하나의 인스턴스만 가지고 있을 때 사용하는 그래프이다. 자원 할당 그래프로부터 자원 유형 노드를 제거하고 적절한 간선들을 결합함으로써 얻을 수 있다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"embedded-asset-block\",\"data\":{\"target\":{\"sys\":{\"id\":\"1KgbHsDVQa9NaUOa2ENG2Y\",\"type\":\"Link\",\"linkType\":\"Asset\"}}},\"content\":[]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"각 자원의 인스턴스가 여러개 일때\",\"marks\":[{\"type\":\"bold\"}],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"뱅커스 알고리즘과 같이 available, allocation, request를 바탕으로 가능한 모든 할당 순서를 조사하는 방식이다.\",\"marks\":[],\"data\":{}}]}]}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"교착 상태 탐지 알고리즘 사용하는 시기\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"unordered-list\",\"data\":{},\"content\":[{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"교착 상태가 얼마나 자주 발생하는가\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"교착 상태가 일어나면 통상 몇 개의 스레드가 원인이 되는가\",\"marks\":[],\"data\":{}}]}]}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"교착 상태가 자주 일어난다면 탐지 알고리즘을 자주 돌려야한다. 반대로 너무 늦게 탐지 알고리즘을 돌리게 되면 교착 상태에 연관된 스레드가 늘어나기 때문에 적절히 돌려야한다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-2\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"교착 상태 회복 방법\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"탐지 알고리즘이 교착 상태가 존재한다고 하면, 여러 대안의 처리 방법이 있다. 운영자가 수작업으로 처리하거나 시스템이 자동으로 처리하게 된다. 교착 상태를 깨뜨리는 데는 한 개 이상의 스레드를 중지하거나 하나 이상의 스레들로부터 자원을 선점하는 두 가지 방법이 있다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"프로세스와 스레드 종료\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"unordered-list\",\"data\":{},\"content\":[{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"교착 상태 프로세스를 모두 중지\",\"marks\":[{\"type\":\"bold\"}],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"확실한 교착 상태의 사이클을 깨주지만 비용이 크다. 기존에 계산중이던 결과들을 모두 내려놓고 다시 계산해야하기 때문이다.\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"교착 상태가 제거될 때까지 한 프로세스씩 중지\",\"marks\":[{\"type\":\"bold\"}],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"하나씩 제거 할때 마다 교착 상태 탐지 알고리즘을 호출해 상당한 오버헤드를 일으킨다.\",\"marks\":[],\"data\":{}}]}]}]},{\"nodeType\":\"heading-3\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"자원 선점\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"교착 상태가 깨질 때까지 프로세스로부터 자원을 계속 선점해 이들을 다른 프로세스에 주어야한다.\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"ordered-list\",\"data\":{},\"content\":[{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"희생자 선택 selection of a victim\",\"marks\":[{\"type\":\"bold\"}],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"비용을 최소화할 수 있는 선점 순서를 결정해야한다.\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"후퇴 rollback\",\"marks\":[{\"type\":\"bold\"}],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"결정된 프로세스를 안전한 상태로 롤백 시켜야한다. 일반적으로 완전히 롤백시킨다.\",\"marks\":[],\"data\":{}}]}]},{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"기아 상태 starvation\",\"marks\":[{\"type\":\"bold\"}],\"data\":{}}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"기아 상태가 일어날 수 있는데 이를 방지하기 위해 롤백 횟수를 기억하는 방법이 있다.\",\"marks\":[],\"data\":{}}]}]}]},{\"nodeType\":\"heading-2\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"참고 자료\",\"marks\":[],\"data\":{}}]},{\"nodeType\":\"unordered-list\",\"data\":{},\"content\":[{\"nodeType\":\"list-item\",\"data\":{},\"content\":[{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"운영체제 Operating System Concepts 10판(퍼스트북, 2020)\",\"marks\":[],\"data\":{}}]}]}]},{\"nodeType\":\"paragraph\",\"data\":{},\"content\":[{\"nodeType\":\"text\",\"value\":\"\",\"marks\":[],\"data\":{}}]}]}","references":[{"contentful_id":"47smr1SMeai1W1TDv2guyv","title":"자원할당그래프","description":"","gatsbyImageData":{"images":{"sources":[{"srcSet":"https://images.ctfassets.net/w6wmczdusxy8/47smr1SMeai1W1TDv2guyv/efcf7758d9145be280214555b3f46866/deadlock1.png?w=63&h=91&q=50&fm=webp 63w,\nhttps://images.ctfassets.net/w6wmczdusxy8/47smr1SMeai1W1TDv2guyv/efcf7758d9145be280214555b3f46866/deadlock1.png?w=125&h=180&q=50&fm=webp 125w,\nhttps://images.ctfassets.net/w6wmczdusxy8/47smr1SMeai1W1TDv2guyv/efcf7758d9145be280214555b3f46866/deadlock1.png?w=250&h=360&q=50&fm=webp 250w","sizes":"(min-width: 250px) 250px, 100vw","type":"image/webp"}],"fallback":{"src":"https://images.ctfassets.net/w6wmczdusxy8/47smr1SMeai1W1TDv2guyv/efcf7758d9145be280214555b3f46866/deadlock1.png?w=250&h=360&q=50&fm=png","srcSet":"https://images.ctfassets.net/w6wmczdusxy8/47smr1SMeai1W1TDv2guyv/efcf7758d9145be280214555b3f46866/deadlock1.png?w=63&h=91&q=50&fm=png 63w,\nhttps://images.ctfassets.net/w6wmczdusxy8/47smr1SMeai1W1TDv2guyv/efcf7758d9145be280214555b3f46866/deadlock1.png?w=125&h=180&q=50&fm=png 125w,\nhttps://images.ctfassets.net/w6wmczdusxy8/47smr1SMeai1W1TDv2guyv/efcf7758d9145be280214555b3f46866/deadlock1.png?w=250&h=360&q=50&fm=png 250w","sizes":"(min-width: 250px) 250px, 100vw"}},"layout":"constrained","backgroundColor":"#f8f8f8","width":250,"height":360},"__typename":"ContentfulAsset"},{"contentful_id":"1KgbHsDVQa9NaUOa2ENG2Y","title":"대기 할당","description":"","gatsbyImageData":{"images":{"sources":[{"srcSet":"https://images.ctfassets.net/w6wmczdusxy8/1KgbHsDVQa9NaUOa2ENG2Y/952a74843346a00d71776c1f8b16d480/deadlock3.png?w=143&h=90&q=50&fm=webp 143w,\nhttps://images.ctfassets.net/w6wmczdusxy8/1KgbHsDVQa9NaUOa2ENG2Y/952a74843346a00d71776c1f8b16d480/deadlock3.png?w=286&h=181&q=50&fm=webp 286w,\nhttps://images.ctfassets.net/w6wmczdusxy8/1KgbHsDVQa9NaUOa2ENG2Y/952a74843346a00d71776c1f8b16d480/deadlock3.png?w=571&h=361&q=50&fm=webp 571w","sizes":"(min-width: 571px) 571px, 100vw","type":"image/webp"}],"fallback":{"src":"https://images.ctfassets.net/w6wmczdusxy8/1KgbHsDVQa9NaUOa2ENG2Y/952a74843346a00d71776c1f8b16d480/deadlock3.png?w=571&h=361&q=50&fm=png","srcSet":"https://images.ctfassets.net/w6wmczdusxy8/1KgbHsDVQa9NaUOa2ENG2Y/952a74843346a00d71776c1f8b16d480/deadlock3.png?w=143&h=90&q=50&fm=png 143w,\nhttps://images.ctfassets.net/w6wmczdusxy8/1KgbHsDVQa9NaUOa2ENG2Y/952a74843346a00d71776c1f8b16d480/deadlock3.png?w=286&h=181&q=50&fm=png 286w,\nhttps://images.ctfassets.net/w6wmczdusxy8/1KgbHsDVQa9NaUOa2ENG2Y/952a74843346a00d71776c1f8b16d480/deadlock3.png?w=571&h=361&q=50&fm=png 571w","sizes":"(min-width: 571px) 571px, 100vw"}},"layout":"constrained","backgroundColor":"#f8f8f8","width":571,"height":361},"__typename":"ContentfulAsset"}]}}},"pageContext":{"id":"32dcbfc1-8352-593b-9c43-e58e8663b0be","slug":"deadlock","__params":{"slug":"deadlock"}}},"staticQueryHashes":["506648845"],"slicesMap":{}}